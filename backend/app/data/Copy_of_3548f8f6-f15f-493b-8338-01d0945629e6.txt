Speaker A:
All right, so the recording is going and I'd love it if we could just start by having you talk to us a little bit more about you as a web developer and the nature of your work.
Speaker B:
Sure. Do you have anything in particular? Should I just start talking?
Speaker A:
You can just start talking.
Speaker B:
All right. So in my spare time, I have a web application that works with firefighters to page out calls through push notifications, Twilio for text messaging, GroupMe for other free chats, and also email. So that acts as a progressive web app with service workers and all that fun stuff and pretty much is as appy as you can get. For my paid work, I do typically just normal HTML web apps. Nothing super fancy with service workers, but lots and lots of web components and typically a team that hasn't done much front end work.
Speaker A:
Makes sense. That web app you have sounds pretty neat.
Speaker B:
It's cool. It's cool. It's way better than the other stuff on the market. Can't complain.
Speaker A:
Nice. Well, one of the things I'd love to do is actually have you spend some time just mapping out your web process and how testing might factor into that. So I put a link in chat. If you can go ahead and click on that, it should open up a tool that we can use to help map out the process. And then I'm going to ship. Perfect. So I'm going to share my screen why this is happening, so that way John can follow along. Okay, so in just a second, you're going to see a horizontal line across the page and you have the ability to add an event. So if you think about. And I'll leave it up to you actually, because we're curious about web testing where if you want to talk about your personal project or your professional project, whichever one you experience more hassles with testing, that can be the one that you go with. And we'd love to know just from a high level, we might dig in with some more details as you map out the process, like what that looks like from beginning to end. And right now the vertical axis doesn't matter. It will in a minute or two. But you have the ability to add events and they'll all populate in the center of the screen and you can just drag them left or right so that they're in chronological order.
Speaker B:
All right. Oh, there's the add event button. I'm clicking on there, thinking things are going to pop up. What kind of event do you want?
Speaker A:
We'd love just to get a better understanding of your process. So if you think about Your project maybe from beginning to end. Like what are some of those major milestones that you end up going through to. To bring something to life?
Speaker B:
All right, so I'll go, you can move around. So you're going to hang out here. All right. So early on in the process, we're going to have some kind of half baked single file app. Just kind of everything thrown together. At some point we're probably going to have some separate files for individual screens. Typically where we go next. I'm going to need to copy Pasta, the login system from the previous app. Get that in there. Let's see. Let me factor into web components. Throw that over here. Basic tests, simple components. Do you want to just focus on UI stuff? You focus on whole project stuff.
Speaker A:
Whole project stuff would be great.
Speaker B:
We get a lot more signs.
Speaker A:
I guess I should say whole project stuff as it relates to development.
Speaker B:
Yeah.
Speaker A:
Okay.
Speaker B:
Get an API in there, get. And then the last stuff that's probably relevant for this discussion would be put that way over here. Come live over here. That's probably what we need for this discussion.
Speaker A:
Awesome. Can you talk to me a little bit more about the API unit tests that you're running?
Speaker B:
Yes. Most likely this is going to be a go project or something written in a easy to test language. Those tests are just going to be built into the language. Feed it some initial data through. Typically it's a SQLite in memory database. If we're doing MySQL if we're doing some other cloudy thing, it's a fake version of the cloudy database, but it'll initialize all the data and then just run through each of the things. This endpoint with this, here's 50 tests. Here's this endpoint with this, here's 50 tests, blah, blah, blah. A whole bunch of stuff there. Basically cover as much as possible. Just the REST API.
Speaker A:
Gotcha. With those test cases that you're running, how big is that test suite?
Speaker B:
It depends on the size of the project and depends on how annoying it is. If it's a simple REST API where it's pretty much just like make a list of users, get a list of users, add a user, delete a user. If it's simple crud stuff, they're pretty small because there's not much going on. We had a project where one of the things was like, it was a whole bunch of microservices. They all talked to each other, they all did a bunch of things. And so you needed to spin up like, you know, here's two fake customers. Here's 50 fake pieces of equipment that the system tracks. Here's the catalog that the customer is interested in. Here's this. And then we're going to build all this junk out. And it got big. Like you end up with easily one to one test to code size. But in a lot of cases, if it's just simple crud, it's not huge at all.
Speaker A:
Gotcha. Okay, and then the other areas in your process where you talk about testing, it looks like down towards the latter end there basic testing around simple components. Can you elaborate on that one for me and help me understand what basic tests mean in this context?
Speaker B:
I switched to web components in what, like 2015 or something? So my goal is always to write everything in as vanilla JavaScript in HTML as possible. Try to break things out into web components. Typically that's components for stupid things that are normal like login and main app and whatever, pickers and selectors and all that. But also pages. Every screen is going to be a web component. Then the goal is to just throw the most minimal tests around. If I make a component, does it have all the default values it's supposed to have? It depends on which ones the simple components would be. The login one where it's like, okay, I can test for state I make the component. There is no loginstate. It should show that signed in is false. If I sign in with this username and password, I should show that sign in is true. Great. I don't want to get too deep into clicking and events and all this stuff. Let's just make sure that I can get something and if I completely break this element, I will get a test telling me that I screwed it up royally. Some stuff with pages, the tests are just going to be, does it have the correct element name? That's pretty much all I'm going to have time for.
Speaker A:
Gotcha. Then what about API and uitestparty? What's that one?
Speaker B:
Yeah, so I haven't had to do this in a couple years, but this is typically the end state that I go for on a large project. So typically most things you can do in the API you can do in the UI and by definition, vice versa. What I've done in the past is create a little API, like a little test scripting language where you say, hey, I want to make a user, here's its parameters and then I want to do nothing for 13 seconds. Then I want to. Let's say we're managing cookies, like food cookies. So then I want to bake six cookies And I want to wait five minutes for the cookies to bake, and then I want to check the oven and see how they're doing. So that's the kind of thing. So then we'll have two implementations. One that reads that and just makes API calls, which is typically like the one you do first because it's super easy. But then the second implementation uses WebDriver to basically do the same thing, but then go to the ui, click the buttons. When it waits to see if the cookies are done, it'll go to the right page, it'll refresh by mashing the refresh button every so often, and verifies that you can do everything you're supposed to be able to do in the UI by inspecting text and using input forms and all that stuff. Then once that's done, if I've got the time. In the past, I've gotten. I don't remember what it's called, but there's some frame buffer that you can get a webdriver to use and start recording nightly MP4s of. Here is the. For workflow one where we make a user and he bakes cookies. Here is that video. What we did with that was we were able to go to our. Not the sales guys, but the product manager guys and say, what demo do you want to give? And we will make sure that every night we build an MP4 of that demo with no voice. But I'm going to click here, I'm going to do this, I'm going to add that. I'm going to do this. We're going to wait for this thing to happen. We give them an MP4 every night of the latest UI and the latest thing. Then all they had to do was slap a voiceover on it and it was ready to go. So that's kind of like the ultimate goal. Rarely do I get to that state in a project. But was it two years ago? We did get that far and it was pretty cool.
Speaker A:
Nice. Why do you think two years ago you were able to get to that state?
Speaker B:
We had a bigger team on that one. So we had a bigger team and we had the most, I want to say, like, hands. Hands in the pie. Product manager that I've had in a while. And he was like, you know, things were always changing every time, like, oh, it should do this, it should do that. Like, all right, well, let's get it written down, let's get requirements. And I think it was like 30 micro services. And we just needed to, like, make sure that everything absolutely worked all the Time and, you know, we had the manpower to do it, so we did it.
Speaker A:
Very cool.
Speaker B:
It was, it was pretty cool.
Speaker A:
It's in stark contrast to what we heard from somebody today who's in the opposite boat from where you were two years ago. Not enough people, not enough manpower, not enough bandwidth.
Speaker B:
Yeah, that's probably where I am with the current product we're working on. Very fortunate. If I can get somebody else to, you know, copy and paste some things in the UI to make a tweak, you know, the chances of them actually going in and making changes or building new screens are like pretty much zero.
Speaker A:
Why do you think that is?
Speaker B:
So most of them are trained. I mean, I think pretty much everybody of my generation at least is trained in like, you know, systems development. So we all had classes on C and C. If you were toward the later end, you learned Java and maybe you got some Python somewhere. And the website was always, you throw some crap together. And if you're fortunate enough to have somebody on the web team that can do stuff, either you throw some junk together in bootstrap or maybe you actually have a team of people that can actually do ui. But those aren't typically the people that like a startup is hiring. So we have, I think like five people on the development team for this product right now and, you know, greatest systems guys I've ever met, like super smart math guys, but, you know, nobody there is interested at all in, you know, rendering anything.
Speaker A:
Interesting. One of the things that I would love to do is just add some guides to this process. And so this is where the vertical axis comes into play. So everything that you've mapped out, I think you already get it.
Speaker B:
Slightly annoying. Not a problem.
Speaker A:
Problem.
Speaker B:
Oh yeah, I don't wish we had. That's not okay. Love doing the API. Little frustrating. Probably not a big deal. Little frustrating. All right, we'll go with that for now.
Speaker A:
Okay, I'm curious, what about the unit tests you've. What about them makes them not frustrating to you?
Speaker B:
So they're extremely rewarding. So I worked at a company that did, you know, multimillion dollar enterprise software with exactly zero tests. And you know, when you screw up in production, you know, it goes to the most senior guy, you know, typically to fix it. And so for a number of years I was getting called it like all hours dealing with all kinds of stupid things. And you know, then it was like, oh, we should maybe have tests. Like, oh, maybe we should use a language that has tests. And you know, since learning the hard way, there is a Calm and a joy in, you know, saving your code. Having the editor basically run some unit tests gives you a thumbs up and knowing that, you know, a change you made today isn't going to completely screw something up that you forgot about from like three years ago. So they are, they're very calming.
Speaker A:
Do you have any tools that you use to support those unit tests?
Speaker B:
In the normal side with go, it's all baked into the language with browser stuff, typically web component tester and it is really annoying to work with.
Speaker A:
Can you elaborate on what makes it annoying to work with?
Speaker B:
So I'm used to I run a command, I get some output, iterate with normal unit tests, go test, and you get a bunch of output and you get a report that says these things failed, these things didn't. Life's great with UI related stuff. A lot of the times you've got to wait around while it spins up browsers or downloads new browser files. There's a reasonable chance that if Chrome works, Firefox doesn't for literally no reason, as far as I can tell. A lot of times you get mismatches between like, the version of the browser installed on my computer is somehow different from the version that the headless thing pulled down and like hid somewhere. And so like you end up with a situation where like, you know, the unit test says one thing, but if you try it yourself it says something else and it's just a big mess. And then some of the unit test things like if you want to go in and debug, I'm thinking of web component tester in particular. Like you end up in a, you know, because it's UI related, like they. You kind of have to open it in a browser and like, here's some things and like here's a report that's also in the browser and it's just like super not intuitive when I'm kind of looking for like, tell me what worked, tell me what didn't work, you know, and let me just, you know, quickly change some lines of code to see how it's going.
Speaker A:
Makes sense. What you've mentioned browsers a couple times. What browsers do you test with?
Speaker B:
Chrome, in all cases, Firefox, if somebody complains. And Safari also if somebody complains. Typically someone on the team will have a Mac laptop of some kind and so Safari will get thrown into the mix. For my personal project, I target mostly Chrome and then I have to go ask a friend to go to my test URL with his iPhone just to make sure that it works. Because Apple is absolutely infuriating with their lack of support for web standards.
Speaker A:
Gotcha. When? Out of curiosity, when you test for web browsers versus browsers on mobile, what are, if any, some of the differences you experience trying to test for those.
Speaker B:
Different platforms for just typical web browser things? Surprisingly enough, in the year 2021, scroll bars are just the stupidest set of things because I guess like Safari just decides to render things however it wants and things get really weird for people. But yes, scroll bars are super annoying because they just make things look horrible other than rendering. So we're rendering for Chrome, we're rendering for Safari, just to make sure Safari doesn't look terrible, then basically just making sure that things work and don't throw exceptions because the syntax is slightly different or one browser allowed something that the other didn't. We ran into an issue, God, what was it two months ago where one browser like on a click event, one browser, Chrome sent some event and Firefox sent a different event and there was no way to make them send the same event. And so we had to just throw a quick if statement and they're like, hey, if there's this property, go ahead and use this XY coordinate. If there's this property. Or maybe no, it was trying to figure out the parent of the event. It's like, if it's this property, it's parent. If it's this property, go in the path thing and look for the first one and that's the guy that should have the event target. That was super annoying. For mobile, it's basically just which subset of modern web component stuff that's relevant. Push notifications, you know, Apple doesn't support that at all. So like, we have to make sure that you fail gracefully. What did I hit the other week? There was, oh, there's a networking API that you can use to detect if you're offline or not. And oh no, it's not network. There's a networking API that works, but there is a, some streaming API broadcast channel, I believe, that lets you communicate between a, a web worker and the main site. And so the web worker knows it's offline and so you just want to communicate, hey, up to the main site, hey, I'm offline. Why don't you show like a little offline icon or gray something out so it makes it clear and the broadcast channel just totally isn't supported. And so when you try to make a new one, it bombs out because it's like, oh, don't know what that is. And then the whole Web worker falls apart. So just stupid stuff like that where you gotta test it, gotta make sure everything works, have to defensively check every class that should exist. Super annoying.
Speaker A:
Gotcha. When it comes to component testing, that's the next one I see on the timeline is basic tester on simple components. Do you test components in isolation?
Speaker B:
Yes, I try to test each simple component and that's the keyword there, you know, like here's the login screen, the login button, the login, whatever the, you know, the component that tells you if you're signed in or not. Here it is, here's its properties, here's a couple things. Does it work? Typically, you know, that's as far as I've been able to comfortably get on component testing because then you get into like mocking rest requests and faking, you know, trying to capture all this stuff. And that's actually another absolutely infuriating thing is the total incomplete made up syntax of things like mocha and Chai, where, you know, it's just, you know, test that dot, this dot is dot equal parentheses 5 and you're like, what does that even mean? That's not a thing. That's not how any of this works. But you know, it's a scripting language, you can do whatever you want and they can, you know, fake and inject anything they want. And it's just like super annoying to pick up where you left off or even make a test from scratch without just like copying and pasting from all over the Internet.
Speaker A:
I take it then that you try and avoid those types of tools.
Speaker B:
I mean, that's just kind of why just like testers kind of floating around the top here. They come in when necessary. But I would love to be building when I'm doing application stuff with the API. It's API and unit test right next to each other. They work great. They're both super easy to do. And then building a UI is not super terrible, but testing around it is just the worst. I would love to have more tests and tests that run faster, but it is just not a friendly environment to work in right now. I'm hoping that. What is it? Webassembly might be able to save us in the next five years, but minimal success with it.
Speaker A:
What is the promising aspects of webassembly that you hope might be able to save this?
Speaker B:
So the number one promising aspect is a single language for the whole application. So if the, you know, all the back ends in go, I can literally write the front end and go to mission accomplished with a webassembly thing, then you get all the unit tests I would have gotten before I get for free. I don't have to spin up browsers or any of that. The scripty aspects of it should be hopefully completely built in and supported and coverable the same way any other interface would be. That I think is super exciting. And then getting rid of JavaScript so that now, you know, things are written in a typed language most places as opposed to, you know, our fun and free language from 1990 that, you know, is somehow still around and driving the web.
Speaker A:
What you're saying is echoed a lot of some open text field responses that we've parsed through with the MDN Web DNA survey. They're, they're quite a hoot at times.
Speaker B:
I bet it's a blast. Programmers are famously opinionated.
Speaker A:
But it's all good and valid opinions. And then what about the API and UITest parity? What's driving some of the frustration there?
Speaker B:
As far as I can tell, it's an unsolved problem and one that's not particularly interesting to people other than me. So, you know, I kind of gave you a use case of, you know, I want to test these higher level ideas. So my higher level idea would be like, you know, user signs up and you know, let's keep using cookies. User signs up, you know, goes to the oven and, you know, bakes a couple cookies, checks the cookies until they're golden brown and then pulls them out of the oven. Cool. The API for that would be super easy. Maybe like six endpoints and you can test it in probably 10 minutes. But to then come up with a language to describe the thing I want to do, I want to sign up. What does signup entail? Well, via the API, that involves, you know, hitting the sign in endpoint, you got to check your email, click the link, you know, set your password for the first time and then let's say hit the account endpoint and make sure that you get back your name. Cool. In the ui. That entails going to some website, filling out some information, also checking your email, also clicking a link and then, you know, getting redirected. Come back, you know, go to the account page and make sure that like your name is correct and you know, that's what I like. I want to test that sign up works as a concept. I don't care that like each individual endpoint works. They all need to stitch together and there's just not a lot of stuff that I found that does a good job of, you know, abstracting that Kind of putting it in a language that you can play with and, you know, it doesn't seem like people are all that interested in it. It's more just like, you know, does my thing work?
Speaker A:
Gotcha. What have you found that you're using now to try and help with that piece of the workflow?
Speaker B:
All homegrown, sort of modeled on the early days of Polymer's declarative syntax. So the goal is to keep like as much as possible and just like, you know, JSON files, maybe with like some special elements for like doing a repeat or special elements for like pulling something from the environment or a special element that references like, you know, the last result of the last whatever it was. So that way you can just have, here is this file, this is the test. And then just set these two environment variables and it'll all work. Also, like, hey, I want to make 10 users. Okay, well, cool, here's the user block and you just wrap it in a repeat with the name is user squiggly bracket I or something like that. Trying to just keep it declarative but, you know, haven't really found anything. I like Gotcha.
Speaker A:
Where do you go to keep track of any changes to testing and the types of tools that are available.
Speaker B:
By accident? So I'll be googling for, you know, trying to figure out how to do something and, you know, so Polymer recommended web component tester for testing web components. And so that's what I've been using for years for Go. Go has its own unit testing. So that's fine for. I'm trying to think of some of the other things, but typically it'll be like, how the hell could I possibly do this? And then, you know, maybe somebody's got a tool, maybe somebody's got an idea, but not something I typically out and look for.
Speaker A:
Makes sense. I guess it makes sense, but I'm curious why you don't go out and look for it.
Speaker B:
Ain't nobody got time for that. I got, what did I do recently? Like, you know, I wish I had time to do the things I want to do. I am currently probably halfway into building a Twilio emulator, which has been the most frustrating thing I have ever done on the entire planet. Twilio is kind of like a real time communication platform that does text messaging and voice calls. And it has support for like literally dialing actual phone numbers, conference calls, that kind of stuff. But it can also do WebRTC and you know, chat between browsers and all kinds of fun stuff. And like hook a Browser up to an actual phone, and they do not offer any kind of test capability. They give you, like two sets of account credentials that you can use to test, like this one endpoint, this one way. And I'm like, I gotta have a conference call set up with like three people, and if one of them drops off, I need the whole thing to fall apart. You know, like, how do I test my workflow? And they're just like, why would you test your workflow? So I am in the process of building an emulator for that and just deep in protocol details and all kinds of proprietary garbage and like, you know, that's what I'm spending my time on. I don't have time to, you know, look around and see if somebody invented a cool new unit testing thing in the last five years.
Speaker A:
Gotcha. Then the last step there, the nightly UI video recording. What is frustrating about that piece in the process?
Speaker B:
A combination of all the other previous steps. Also, to the best of my knowledge, there's nothing great that already exists that works out of the box. So I know I spent weeks trying to get the framebuffer stuff to work with the browser. So the framebuffer stuff, you get a framebuffer, it's X by Y size, great. But when you'd open the browser, the browser would open just in the middle somewhere and it would be 600 pixels wide. And you're like, why don't you be full screen? And browser says, why would I ever consider being full screen? No. So then you fight for weeks on end trying to figure out these dumb little intricacies. Because I want the browser to be at position 00 and go to the maximum height and maximum width because I'm going to record it. Then recording isn't necessarily built in. It's just it talks to a frame buffer. So now I've got to spin up a copy of FFMPEG with a whole bunch of options that I have no idea what they do just to try to get this thing recording. And then it's like, oh, well, guess what? The crappy VM you're using in the cloud isn't good enough to grab at the frame rate you want. And it's just like debugging after debugging after debugging for just like the dumbest things.
Speaker A:
When you've experienced that, has it been what browsers does that tend to be an issue in?
Speaker B:
It's not so much the browsers as much as webdriver.
Speaker A:
Gotcha and any. Is there anything worth elaborating on with that about why WebDriver isn't working?
Speaker B:
No, I mean, just like WebDriver just does like three things, then it does them fairly well. But. Oh, that's the other thing. I haven't worked with WebDriver in a while. Oh my God. Yeah, WebDriver. So WebDriver can, like, it's great when it's great and then like when as soon as something is implemented weird, I'm trying to remember what it is. I know I've got an entire library of workarounds for WebDriver, like where like some click doesn't work and it's like, oh, okay, so instead of this one click, like, let's go find the element and issue like the click command on the Element through the JavaScript API. Because for whatever reason, like WebDriver thinks there's another element in front of this one and there's nothing you can do about it. Webdriver is super low level and I would love for them to be a little less low level also. Trying to pull in and out. You're trying to convert between languages. You're like, okay, WebDriver, here's some JavaScript I want you to run, or I'm going to run this event. And here's some output that I have to somehow convert from random JavaScript into my programming language. You just have checks on top of checks on top of checks. But I remember that being super annoying with the webdriver stuff where you're like, okay, I need to go to screen five and go to this input, type something in and click this button and like, you're looking at 50 to 100 lines of code to just navigate to that screen. And that's like, without trying to like, do it as a user would by like clicking buttons and going to the right spot and verifying that the page changed. You know, if you're just like, ah, screw it, like, I'll just change the header and go here and you know, it's just, there's a lot of work you have to throw on top of it just to make it do the stuff you want. And then you go to the input and you're like, cool. You type and it's like, well, guess what? It doesn't work because it's not in focus. You can't click on it. Here's the element. Move to the element. Focus the element. Where's my scroll bar? Do this, do that. A lot of annoying work, especially if you're trying to do videos. A lot of unit testing with browsers. It's click, click, click, does it all work? Great, but I need to simulate scrolling because part of the end user experience is that the scrolling works and this is good and it doesn't just jump around. Now you're building frame loops where it's like, okay, I'm going to scroll this many pixels, let's do it over the course of two seconds. Because that seems normal. Now I have to issue these incremental scrolly things. Just a lot of dumb things.
Speaker A:
Makes sense. I tend to live more on the UI design side, so it's really interesting to hear the developer's point of view on this space.
Speaker B:
I am extremely an outsider in it. I'm here because I'm the guy on the team that's willing to do it. So I've been building the front and the backside of applications for years and you know, I miss the simplicity and the crispness and the clarity of just like, you know, here's how a system tool works. Browsers are just so magical and you know, I guess like they change every day and like, oh, come on.
Speaker A:
Which I guess brings me to another question I have for you. How often, like what, what is the time that you end up spending on testing in a process like this?
Speaker B:
So in this particular process where I've actually like done the work, so for unit tests around like API things, you know, I'd say a third of the time. Potentially, again, it's going to depend on like how ridiculously nasty the stuff is that needs to be tested. But, you know, spending a good chunk of your time on tests, maybe a third to a quarter, is perfectly normal for that. For the ui, I spend a whole lot less than I should just because it's so frustrating. But the nightly video recording stuff, like, when that works, I don't worry about it too much. But when that breaks, you know, sometimes it's weeks of trying to figure out like, what do I need to jiggle to make this, you know, video work the way it's supposed to work?
Speaker A:
Does it break regularly?
Speaker B:
No, it does not. So that's good.
Speaker A:
Good. And then are you happy with the amount of effort that you spend? I mean, I know you just said that UI testing, you don't spend as.
Speaker B:
Much time as you for UI testing. I'm not happy with the very low results to effort that you put in. I feel like I put in a huge amount of effort in UI testing to get very little out. I am not happy with that.
Speaker A:
Gotcha. You do have the ear of some comfort Limozilla and some other sponsors to this work. Like what Would, what would you like to tell them to help make that better and less frustrating and more time efficient for you?
Speaker B:
I think, I think some of it would be standardize more so, you know, there's no. And like again, like I know that's not something Mozilla can do on its own, but like there's no, you know, W3C on you know, unit tests. And so if you use, what is it? Web component testers, you then, you know, make a test web page that includes some stuff that then you create these elements, I think they're called fixtures and then you put some stuff in there and they're poorly documented. And you know, sometimes it makes new things, sometimes it don't. You have to read the instructions. And this is kind of like why, like I get that it's a browser, but why am I making new web pages to test web pages? Like can I just test this thing in some way that doesn't involve setting up a head tag and a body tag? And come on. The whole point of this is that I'm in a web page. I don't want to be making web pages to test my web pages. Some of it is just the tooling is non standard at best. You've got these guys like Mocha and Chai and they've been around for ages and they're the de facto standard. But that doesn't mean it's good. We've got with web workers, we now have the ability for the browser to capture all web requests and intercept and do whatever it wants and lie, cheat and steal and you'd never know the difference. And I'd love to see some of that get brought into just like, oh yeah, here is some native JavaScript to say I'm going to test this thing and when I'm going to intercept all web traffic out of my domain and if it's this, do that. If it's this, do that instead of having to, I guess the ant like the root of it is, it's all magic. So like you know, in a real programming language that's compiled and you know, strong types, everything is clear what's happening, there's no surprises. Then you get kind of like into the higher level things like Java where you can start doing dependency injection and lying about what classes are and it's okay, fine, but I kind of see what's going on. Then you get into JavaScript which is what you need to use to test browser stuff. And it is just made up. You can't inspect an element. You've got A variable. You're like, okay, browser, console, tell me what I can use on this variable. It's like nothing because all the getters and setters are routed to functions that do whatever they want to do and they spit out things that they want to spit out and dynamic functions everywhere. And, you know, it's just absolutely nuts. And then I think part of it also is because JavaScript is such like a ubiquitous and accessible language, a lot of the stuff online is utter garbage. So, you know, like any 12 year old can like, you know, write an article about how to properly do something. And the barrier to entry in like GO and Java and C is way higher, so you get way less garbage. You still get people that are wrong about things, but they're not wildly wrong all the time. But so much JavaScript is just like, oh yeah, you copy and paste this, you do some of this stuff, it'll all work out. No, it won't. What are you doing? It's the frustrations I have. I don't know exactly what would make, you know, what would make my life easier, maybe other than just like, you know, baking in the concept of unit tests into the browser. So, like, the GO compiler also is the GO unit tester. There's no separate suite of tools. It's extremely opinionated on what it wants you to do and it kind of forces you to do things the right way, which is super awesome. But I understand that browsers have, you know, decades and decades of, you know, weird things and doing it their own way and a totally different kind of standardization. Yeah, just like minimizing the number of things I need to track down and install. I guess, like minimizing dependency hell would make my life a whole lot easier, you know, so I've already written the web component. I already have a browser. Why is there literally anything else I should need in order to test this?
Speaker A:
Gotcha. Well, I have two more questions for you, but before I ask them, John, do you have anything you'd like to follow up on?
Speaker B:
No, I think, I think he's covered everything that I had checked off.
Speaker A:
Great. So, Doug, two more questions for you. We spent quite a bit of time talking about the tests that you do do. Are there certain types of tests that you don't do?
Speaker B:
So the ones that I don't do are probably the ones that I can't do. I'm trying to think of what I would like to do that I can't. So I'd like to. I'd like to do more video stuff. I'd like to do more screenshot stuff I'd like to do, I'd honestly just like to do more UI unit testing in terms of systems and daemons and all that kind of stuff that is relatively super easy to test. Sometimes you have to build an emulator, sometimes you have to build a simulator. But that level of work is typically straightforward. It's just some protocol reverse engineering. God. UI stuff is just absolutely a nightmare. Part of it also is structural. Back to built in Go. The file that tests the file is typically like name of the file test. If I've got user go, the file with all the unit tests is usertest Go. They live next to each other. It's great. With the web component stuff, the JavaScript stuff that I've seen, most people have a separate directory structure where the tests live. I guess because you've got Node and its package management grab stuff in a directory maybe I don't know how it works, but having the tests live right next to the things they test I've found to be super helpful. And when you're doing UI stuff, I guess a lot of people don't like to have their tests just littered all throughout the rest of their stuff. But that I think would be helpful. Encourage me to make more tests and encourage me to put them where they belong, not hidden in a test directory somewhere that I'm only going to find when it turns out my test break.
Speaker A:
Gotcha. Okay, well, with the last five minutes here, I want to flip it back to you and see if there's anything that you were hoping we would talk about and didn't get the chance to or other things or advice that you would like to give when it comes to web testing.
Speaker B:
No, I had, I had no expectations. I had no idea what I was getting in for. So this was good.
Speaker A:
Great.
Speaker B:
I didn't realize. So the little diagram was nice in that it made me realize I really need to put more effort into finding some system for testing UI stuff because the amount that is currently covered is probably bordering between 0 and 1%, which is appalling. Whereas like, you know, my other stuff is somewhere probably between like 50 and 60% coverage. You know, the typically like on UI unit tests I frequently get as far as making sure the tool chain works. And that's part of the other issue too is, you know, the tool chain. So like, you know, it's all Docker containers that get spun up and down in Jenkins, whatever. The UI testing stuff is typically like a gigabyte container because it's got to have all the browsers and the fonts and the this and the that. Whereas, you know, the compiler container for go is like three megabytes. It's probably 20, but, like, it's not a lot. 20 megabytes tops, you know, so it's much more lightweight, it's way faster and easier. And then it's just to do browser testing. It's a lot heavier, it's a lot slower, there's more download time, and you have to get all the browsers set up on the versions you need in advance, because if you did it at pull time, you'd be wasting 20 or 30 minutes doing installs and upgrades just to make this stuff work. You've got to get it all prepped ahead. But, yeah, that's pretty much my set of frustrations is it's just not easy to test, it's certainly not easy to automate, and then it's definitely not easy to do in a headless container fashion where I don't have any debugging capability.
Speaker A:
Makes sense. I'm curious if it's not easy. Do you have an analogy of something in your life that is easy and that you would like UI testing to be similar to?
Speaker B:
So the thing that I've come up with when I talk about this kind of stuff is physical therapy. So, like, you know, I feel like when I'm doing UI stuff, like, I am doing highly dexterous things with my weak arm. And, you know, I train my weak arm. So, like, I try to play both of them, but anytime I have to do something with a UI test or something with some UI thing that I'm not super familiar with, it's just like, I'm weak, I'm slow, I'm uncoordinated. The things that I want to do, my body just won't. I'm like, look, I just want to test this. And like, nope, can't do that, buddy. Like, you've got to do all these other steps. And so, yeah, it feels like I'm in physical therapy for something, like, you know, for weeks and weeks and weeks on something that, like, you know, the whole point of being in physical therapy is it should be quick and easy. Yes. You're just walking down the street, it should be easy. But, like, nope, your leg doesn't work. And so that's how I. That's how I describe it to everybody. Physical therapy. I'm just struggling with something that feels like it should be easy, but, like, I have to do each individual thing, you know, typically with the help of a coach. And then there's exercises. And you know, if you talk to anybody about it, you're going to get 30 different opinions, like, oh, like, well, my guy told me this. Like, well, my sister's a PT and she says, like, oh my God, I'm just trying to walk.
Speaker A:
Well, that might be my favorite analogy. And John's got a background as a personal trainer, so I'm sure he's, he's loving it as well.
Speaker B:
Oh, my man. Actually. Yes. Because I can't tell you how many clients I've been like, you need to go see PT about this specific thing. But you don't have to tell them. And they'll come back and they'll be like, oh my God, how did you know? And I'm like, that's right.
Speaker A:
Well, I don't want to take up any more of your time than we asked for, but this has been really insightful and I think we've got a lot of really good information to add to the body of work that we have with this study. So thank you for meeting with us today.
Speaker B:
No, thank you. This is super interesting. And is there going to be like, what, like a paper at the end of this, some kind of conclusions? Like, what should I be looking for?
Speaker A:
Yeah, the plan would be to write up the report based on the interviews that we've done and most likely publish it on the Insights Indian Insights URL where the, where the 2019 and 2020 report is published. And last year when we did this study, the stakeholders decided to do a deeper dive on browser compatibility and that report is up on that URL as well. So there will be a summary report that highlights the findings and hopefully some commitments from stakeholders around what they'd like to do as a result of this work.
Speaker B:
Oh, hold on. Add one more thing to your list. So, and this, this isn't anything you can do, but the tutorialspoint.com and w3schools.com need to be destroyed and removed from the Internet. And Google used to let me be able to block sites from my search results and they no longer do this. So like I, I now have to prefix everything I'm doing with MDN. So like any web element, any JavaScript, just MDN this. I don't want to see all these dumb things. I want like the nice Mozilla docs that are the best on the Internet. You know, I. That is super. Like I just typed in formaction HTML and it's tutorialspoint, w3schools, tutorialspoint w3schools, HTML.com, whatever that is, Stack Overflow and Then here it is at the very bottom. Here is the MDN form action stuff. Yes, thank you. That's what I'm interested in.
Speaker A:
What does MDN do well over the other ones that you try and avoid?
Speaker B:
It's just actual good documentation in addition to having all the formal words. And the stuff that's important, the syntax, the examples are typically the browser compatibility charts. Great. And it doesn't try to do anything cute. It's just like, here's the form action property. Click the form element to learn more. Here's some example. It's a string. And here's the link to the standard it came from, if you don't believe me. Cool. It's not just filled with ads and things. And what is W3 tutorial? What's W3 schools do? W3 schools. It's like you get an example of one thing, and so it's never good enough. It's like, okay, yes, that's what a form looks like. I've seen thousands of forms. But this doesn't answer my question. For the browser support, it's like Chrome, ie, Firefox, Safari, and Opera. Okay, great. What versions? Why would we mention, you know, here's okay. The attribute value is okay, reasonably documented, but just now it's no good. It doesn't link me back to the stuff I'm interested in. It doesn't talk about anything. Yeah. So the MDN stuff is just like really, really quality stuff. And it should be higher up in the search results.
Speaker A:
Making note, we'll make sure that that gets told back to the timothy.
Speaker B:
All right, I think that's all I have for you.
Speaker A:
Okay, well, thank you again. I really appreciate it. Congratulations again on getting your second dose of the vaccine. And thank you.
Speaker B:
Hopefully, hopefully it doesn't get too bad out here.
Speaker A:
Hopefully not.
Speaker B:
All right, take it easy, guys. Thank you.
Speaker A:
Thank you.
Speaker B:
You too.